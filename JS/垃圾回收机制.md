JavaScript 的垃圾回收主要经历过两种方式：

1. **引用计数**：每个对象维护一个引用计数器，被引用时+1，引用关系解除时-1，计数为 0 就回收。但缺点是**循环引用**时对象不会释放，导致内存泄漏
2. **标记-清除**：现在主流的方式。以全局对象为根，遍历能访问到的对象并打上标记，未被标记的就是不可达对象，会在清除阶段被回收。这样解决了循环引用的问题

V8 采用分代回收：

- 新生代对象用复制算法，回收快，适合生命周期短的对象
- 老生代对象用标记-清除和标记-整理，避免内存碎片  
  同时还有增量标记、惰性清理来减少回收时的卡顿

内存泄漏产生的原因一般有：

- 全局变量未释放
- 闭包里有无用引用
- DOM 元素被移除但事件监听没解绑
- 定时器/回调忘记清理
