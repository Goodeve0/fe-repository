### 全局变量、函数

在早期的`JavaScript`开发中，`JavaScript`没有内置的模块系统，通常使用全局变量、函数来组织代码

```js
// a.js
function add(x, y) {
  return x + y;
}
var sum = add(1, 2);
console.log(sum);

// b.js
function add() {}
```

#### 存在的问题

- 容易出现命名冲突以及代码复杂性的问题
- 模块成员之间看不出直接关系

### 命名空间(namespace)

针对全局变量、函数这种方式存在代码污染和命名冲突的问题，引入了命名空间的概念，通过将相关的函数、变量和对象放在命名空间中，实现了代码的封装和组织

```js
var MyApp = {
  score: 100,
  add: function (x, y) {
    return x + y + this.score;
  },
};

var sum = MyApp.add(1, 2);
MyApp.score = 1;
```

#### 存在的问题

数据不安全(外部可以直接修改模块内部的数据)，无法按需导出  
如果我只想暴露 add 方法，我的 score 属性也不得不暴露，并且外部还可以直接修改 score 属性，造成了数据的不安全

### 立即执行函数 IIFE

为了解决命名空间无法按需导出、数据不安全问题。将代码包装在一个匿名函数中，避免污染全局命名空间，并立即执行这个函数，这种方式叫立即执行函数

#### 用法

```js
(function (x) {
  console.log(x);
})(1);
```

#### 例子

```js
var MyApp = (function () {
  var score = 100;
  return {
    add: function (x, y) {
      return x + y + score;
    },
  };
})();

var sum = MyApp.add(1, 2);
console.log(sum);
```

无法修改 score 的值，可以按需导出。

### CommonJS

`CommonJS`是为服务器端开发提供了一种同步加载模块的方式，这种模块机制非常适合服务器端环境，因为文件系统的 IO 操作是同步的，解决模块化和依赖管理的问题

#### 用法

- 导出用 `module.exports/exports`
- 导入用 `require`

#### 例子

```js
// add.js
function add(x, y) {
  return x + y;
}
module.exports = add;
// main.js
const add = require('./add.js');
const sum = add(1, 2);
console.log(sum);
```

### AMD

开发中对于异步加载的需求越来越多，RequireJS 推出了 AMD 规范，允许在代码运行时异步加载模块，通过`define`和`require`来定义和引用模块，解决了模块依赖管理和异步加载的问题

#### 例子

math.js

```js
// 定义名称，依赖项，导出模块
define('math', [], function () {
  return {
    add: function (a, b) {
      return a + b;
    },
  };
});
```

main.js

```js
// 加载完成后将math返回的对象以参数传递给回调函数
require(['math'], function (utils) {
  console.log(utils.add(1, 2));
});
```

index.html

```html
<script src="https://cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.js"></script>
<script src="./main.js"></script>
```

#### 存在的问题

如果引入了多余的依赖，没有进行区分是否调用，都会进行加载

### CMD

CMD（通用模块定义）是由 SeaJS 提出和实现的一种模块化规范。SeaJS 是一个遵循 CMD 规范的 JavaScript 模块加载器，可用于浏览器端的模块化开发。

专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。

### UMD

UMD 是一种通用的模块定义规范，旨在解决不同模块加载器和环境之间的兼容性问题。它的设计目标是使同一个模块可以在多种环境下使用，例如浏览器、Node.js 等

#### 思路

UMD 的基本思想是先检测当前环境是否支持 AMD 规范，如果支持则采用 AMD 方式加载模块；如果不支持，再检测是否支持 CommonJS 规范，如果支持则采用 CommonJS 方式导出模块；如果两者都不支持，再将模块挂载到全局对象上。这样一来，无论在什么环境下，都能够正确地加载和使用 UMD 模块。

### ESM

随着 ES6 发布，JS 原生支持了模块化，引入`import`和`export`关键字来定义和引用模块。ESM 提供了一种静态分析的模块加载方式，使得代码更易于优化和打包。

### CJS 和 ESM 区别

1. **用法不同**
   - ES module 使用`import/export`关键字实现模块的导入和导出。
   - CJS 采用`require`和`module.exports`实现模块的导入和导出
2. **加载方式不同**
   - 编译时加载：ES6 模块不是对象，而是通过`export`显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”
   - 运行时加载：`CommonJS`模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，也就是“运行时加载”
3. **导入和导出特性不同**
   - ES module 支持异步导入，动态导入和命名导入等特性，可以根据需要动态导入导出，模块里面的变量绑定其所在的模块
   - CommonJs 只支持同步导入导出
4. **循环依赖处理方式不同**
   - ES module 采用在编译阶段解决并处理：ES Module 通过使用模块间的以来地图来解决死循环问题，标记进入过的模块为“获取中”，所以循环引用时不会再次进入
   - CJS 通过第一次被`require`时就会执行并缓存其 exports 对象。这样在循环引用中，CJS 就会提供一个**部分导出对象**(partial exports)，从而打破无限循环。如下，a 文件引用 b，b 文件引用 a
   ```
   main.js
      └──> a.js
            └──> b.js
                   └──> a.js (cached partial exports)
   ```
5. **兼容性不同**
   - ES module 需要在支持 ES6 的浏览器或者 Node.js 版本才能使用
   - 而 CJS 的兼容性会更好
6. **CommonJs 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**
   - CommonJs 模块输出的是值的拷贝（浅拷贝），也就是说，一旦输出一个值，模块内部的变化就影响不到这个值
   - ES6 模块的运行机制与 CommonJS 不一样，JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行的时候，再根据这个只读引用，到被加载到那个模块里面去取值。原始值变了，import 加载的值也会跟着变。因此，ES6 是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
