### 性能指标

### vue2 和 3 区别

### vue 和 react 区别

### 输入 url 到展示的流程

### 页面渲染的过程

浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：

1. 解析 HTML：解析 HTML 并构建 DOM 树
2. 解析 CSS：解析 CSS 构建 CSSOM 树
3. 合成渲染树：将 DOM 与 CSSOM 合并成一个渲染树（Render Tree）
4. 布局计算：根据渲染树的结构，计算每个节点在屏幕上的大小、位置等属性，生成布局信息，这个过程中会发生回流和重绘。
5. 绘制页面：将生成的布局信息交给浏览器的绘图引擎，通过 GPU 加速将像素绘制到屏幕上
6. 浏览器回流和重绘：如果页面发生改变，浏览器需要重新计算布局和绘制，这可能会导致性能问题。因此我们尽量避免频繁的 DOM 操作和调整元素样式，以减少不必要的回流和重绘。

### vue 组件通信的方法

### flex 布局

Flex 是一种一维的弹性布局模型，它由父容器和子项目组成。  
当一个元素变成了 Flex 容器之后，它的子元素，包括其伪元素::before、::after 和文本节点都将成为 Flex 项目。HTML 中的可替代元素是无法成为 Flex 容器的，比如 img、 input、select 等元素。
Flexbox 中的主轴由 flex-direction 属性设置，默认情况下，主轴沿行方向分布，如果该属性为 column，则主轴沿列方向分布.
Flexbox 布局中有一个强大的特性，当 Flex 容器有剩余空间时：
● 可以使用主轴的对齐方式 justify-content 来分配主尺寸的剩余空间;

| 属性值          | 说明                                          | 效果                       |
| --------------- | --------------------------------------------- | -------------------------- |
| `flex-start`    | 默认值，项目从主轴起点开始排列                | 全部靠左（或靠上）         |
| `flex-end`      | 项目从主轴终点开始排列                        | 全部靠右（或靠下）         |
| `center`        | 所有项目在主轴上居中排列                      | 居中对齐                   |
| `space-between` | 两端对齐，项目之间的间距相等                  | 头尾贴边，中间等间距       |
| `space-around`  | 每个项目两侧间距相等（项目间距是边距的 2 倍） | 两边留半间距，中间留整间距 |
| `space-evenly`  | 所有间距（项目间和边缘间）都相等              | 完全平均分布               |

● 可以使用侧轴的对齐方式 align-content 来分配侧尺寸的剩余空间。

| 属性值       | 说明                                         | 效果             |
| ------------ | -------------------------------------------- | ---------------- |
| `stretch`    | 默认值，若项目未设置高度，会被拉伸至充满容器 | 自动拉伸填满高度 |
| `flex-start` | 从交叉轴起点对齐                             | 顶部对齐         |
| `flex-end`   | 从交叉轴终点对齐                             | 底部对齐         |
| `center`     | 在交叉轴上居中                               | 垂直居中         |
| `baseline`   | 按文本基线对齐                               | 文本底部对齐一致 |

### Promise

#### Promise 的方法

### type 和 interface 区别

### vue 响应式原理

### vue 静态提升有了解过吗

Vue 3 在编译阶段引入了静态提升机制。编译器会在模板编译时分析哪些节点或属性是静态的，把它们提升到渲染函数外部，只创建一次并在每次渲染时复用，从而避免重复创建虚拟节点和比较操作，大幅提升渲染性能。
另外，它还结合 patchFlag 精确标记动态部分，让运行时只更新必要的节点，这就是 Vue 3 性能优化的核心之一。

### 手写

#### 快速排序

#### 防抖&节流

### 反问

上海蔚来，技术栈 Vue 为主，也有 React

感谢信，下次再也不梦到哪句说哪句了
