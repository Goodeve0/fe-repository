## 面试题

### useLayoutEffect 和 useEffect 区别及使用

| 特性     | useEffect                                        | useLayoutEffect                                       |
| -------- | ------------------------------------------------ | ----------------------------------------------------- |
| 执行时机 | 异步，在浏览器完成渲染后执行                     | 同步，在 DOM 更新后、浏览器绘制前执行                 |
| 影响     | 不会阻塞页面渲染                                 | 会阻塞渲染，可能影响性能                              |
| 使用场景 | 绝大多数副作用逻辑：请求数据、订阅事件、打印日志 | 需要读取/操作 DOM，并避免闪烁：测量 DOM、同步滚动位置 |

### this 指向

### 状态管理 useContext 和 zustand 使用场景

#### useContext

特点：React 内置，主要用于跨层级组件传值，避免繁琐的 props drilling。

适用场景：轻量级全局状态，如主题（light/dark）、多语言切换、登录用户信息等状态变化频率不高的场景。项目结构简单，不需要额外引入状态管理库。

⚠️ 问题：当 context 的 value 变化时，所有消费它的子组件都会重新渲染，可能造成性能问题。

#### Zustand

特点：第三方轻量状态管理库，基于 hooks，API 简洁，不依赖 React context 的重渲染机制。

适用场景：中大型应用：跨页面、跨模块共享状态，如用户数据、购物车、全局缓存。频率更新的状态管理（如实时数据流、WebSocket 消息）。

想要细粒度控制渲染（Zustand 可以只触发用到的 state 的组件更新）。

#### ✅ 对比总结

useContext 更适合简单共享、低频更新的全局状态。

Zustand 更适合复杂共享、高频更新的全局状态。

### ssr 和 csr 区别以及使用场景 hydration 怎么处理优化

### 受控组件和非受控组件

#### 受控组件

定义：表单组件的值由 React 状态（state）接管，组件本身只负责触发事件

特点：

- value 始终取决于 state
- onChange 事件必须更新 state 才能改变输入值
- 数据流可控，方便做校验、格式化、条件渲染

使用场景：表单验证、复杂交互场景（如搜索框实时校验、动态联动表单）

示例

```js
const [value, setValue] = useState('');
<input value={value} onChange={(e) => setValue(e.target.value)} />;
```

#### 非受控组件

定义：表单组件的值由 DOM 自己管理，通过 ref 获取值
特点：

- 不依赖 state，避免频繁渲染
- 使用`defaultValue`/`defaultChecked`初始化值
- 更接近原生表单
  使用场景：性能要求高的场景（比如长表单，输入不需要实时校验）以及第三方库表单
  示例：

```js
const inputRef = useRef < HTMLInputElement > null;
<input ref={inputRef} defaultValue='hello' />;
// 获取值
console.log(inputRef.current?.value);
```

#### ✅ 总结

受控：更适合需要实时控制、验证和复杂逻辑的表单。

非受控：更适合轻量、性能优先、与第三方库结合的表单。

### let var const const 声明什么才可以改动 为什么->引用类型和基本类型区别

### flex 布局和 grid 布局的区别

#### 1. 定位不同

Flex（弹性布局）

- 一维布局（单行或单列）
- 主要用于一条轴线上的对齐和分布

Grid（网格布局）

- 二维布局（行+列）
- 可以同时处理水平和垂直两个方向的对齐和分布

#### 2. 使用场景

Flex：内容驱动

- 项目大小不固定，由内容决定空间分配
- 更适合内容自适应的场景
  Grid：布局驱动
- 先划分网格区域，再把元素放入对应的格子里
- 更适合页面整体的框架设计

### 选择器优先级排序

### key 的值为什么不能是 index

1. `key`的作用：在更新列表时，会用`key`来判断节点是否可以复用（相同`key`->复用旧节点），以及判断节点是否要新建。有了`key`，能够快速找到真正变化的节点，只更新差异部分。

2. 不能用`index`作为`key`值是因为，在增删、排序时，`index`会变化，导致 DOM 复用错误，UI 错乱

3. 正确做法：用业务数据的唯一 ID 作为`key`值

### Websocket 是什么，和 http 有什么区别

WebSocket 是 HTML5 提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于 TCP 传输协议，并复用 HTTP 的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。  
**区别**

1. 连接方式

HTTP：短连接（1.0 默认），请求-响应一次就断开。HTTP/1.1 虽然支持 Keep-Alive，但本质还是“请求-响应模式”。

WebSocket：先通过 HTTP 发起 握手请求（Upgrade 请求头）。握手成功后，协议升级为 WebSocket，保持一个 全双工长连接。

2. 通信模式

HTTP：单向通信 → 客户端请求，服务端响应。服务端不能主动推送。

WebSocket：双向通信 → 建立连接后，客户端和服务端都能主动发消息。

3. 数据传输

HTTP：基于文本（头信息占用较大），传输效率低。

WebSocket：基于 帧（frame）传输，支持二进制和文本，数据包小，效率更高。

4. 使用场景

HTTP：适合请求一次就能拿到结果的场景，例如网页加载、接口请求。

WebSocket：适合需要 实时交互 的场景，例如：即时通讯（IM 聊天）、股票&K 线图实时推送、在线游戏、实时协作（文档、白板）

5. 性能对比

HTTP 轮询：客户端需要不断请求服务器，有大量无效请求，延迟高。

WebSocket：服务端只在有数据时才推送，延迟低、资源消耗少。

### 聊下重传实现

### vite 带来了哪些优化 -> webpack 和 vite 区别

### 手写

判断传入的数组是否为空或者对象是否没有键值对  
eg1. obj = {a:1, b:2} false  
eg2. arr = [] true  
eg3. arr = [1, null, 2] false

```js
const isEmpty = (target) => {
  if (Array.isArray(target)) {
    return target.length === 0;
  } else if (target !== null && typeof target === 'object') {
    return Object.keys(target).length === 0;
  }
  return false;
};
let obj = { a: 1, b: 2 };
let obj1 = {};
let arr = [1, null, 2];
console.log(isEmpty(obj), isEmpty(obj1), isEmpty(arr));
```

题外话：面试官有种温柔大姐姐感~~好喜欢~
